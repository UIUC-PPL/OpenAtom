qgeqr2.f:*  DGEQR2 computes a QR factorization of a real m by n matrix A:
qgeqr2.f:*  where tau is a real scalar, and v is a real vector with
qgeqrf.f:*  DGEQRF computes a QR factorization of a real M-by-N matrix A:
qgeqrf.f:*  where tau is a real scalar, and v is a real vector with
qggbak.f:*  DGGBAK forms the right or left eigenvectors of a real generalized
qggbal.f:*  DGGBAL balances a pair of general real matrices (A,B).  This
qggev.f:*  DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
qggev.f:*          the j-th eigenvalue is real; if positive, then the j-th and
qggev.f:*          their eigenvalues. If the j-th eigenvalue is real, then
qggev.f:*          abs(real part)+abs(imag. part)=1.
qggev.f:*          their eigenvalues. If the j-th eigenvalue is real, then
qggev.f:*          abs(real part)+abs(imag. part)=1.
qgghrd.f:*  DGGHRD reduces a pair of real matrices (A,B) to generalized upper
qhgeqz.f:*  DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
qhgeqz.f:*  generalized upper Hessenberg form of a real matrix pair (A,B):
qhgeqz.f:*  The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
qhgeqz.f:*  complex and beta real.
qhgeqz.f:*  Real eigenvalues can be read directly from the generalized Schur
qhgeqz.f:*          The real parts of each scalar alpha defining an eigenvalue
qhgeqz.f:*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
qhgeqz.f:*        Note: the Francis double-shift should work with real shifts,
qhgeqz.f:*              a 2x2 block with real eigenvalues.
qhgeqz.f:*           If standardization has perturbed the shift onto real line,
qhgeqz.f:*           do another (real single-shift) QR step.
qladiv.f:*  DLADIV performs complex division in  real arithmetic
qlag2.f:*          will always be positive.  If the eigenvalues are real, then
qlag2.f:*          the first (real) eigenvalue is  WR1 / SCALE1 , but this may
qlag2.f:*          eigenvalues are real, then the second (real) eigenvalue is
qlag2.f:*          If the eigenvalue is real, then WR1 is SCALE1 times the
qlag2.f:*          eigenvalue is complex, then WR1=WR2 is SCALE1 times the real
qlag2.f:*          If the eigenvalue is real, then WR2 is SCALE2 times the
qlag2.f:*          WR1=WR2 is SCALE1 times the real part of the eigenvalues.
qlag2.f:*          If the eigenvalue is real, then WI is zero.  If the
qlag2.f:*        Choose (real) eigenvalue closest to 2,2 element of A*B**(-1)
qlag2.f:*     Scale second eigenvalue (if real)
qlaln2.f:*  A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
qlaln2.f:*  real diagonal matrix, w is a real or complex value, and X and B are
qlaln2.f:*  NA x 1 matrices -- real if w is real, complex if w is complex.  NA
qlaln2.f:*  the first column of each being the real part and the second
qlaln2.f:*          1 if "w" is real, 2 if "w" is complex.  It may only be 1
qlaln2.f:*          complex), column 1 contains the real part of B and column 2
qlaln2.f:*          The real part of the scalar "w".
qlaln2.f:*          the real part of X and column 2 will contain the imaginary
qlaln2.f:*          real matrix.
qlaln2.f:*           Real 1x1 system.
qlaln2.f:*        Compute the real part of  C = ca A - w D  (or  ca A**T - w D )
qlaln2.f:*           Real 2x2 system  (w is real)
qlaln2.f:*              Code when off-diagonals of pivoted C are real
qlaln2.f:*              Code when diagonals of pivoted C are real
qlange.f:*  real matrix A.
qlarfb.f:*  DLARFB applies a real block reflector H or its transpose H**T to a
qlarfb.f:*  real m by n matrix C, from either the left or the right.
qlarf.f:*  DLARF applies a real elementary reflector H to a real m by n matrix
qlarf.f:*  where tau is a real scalar and v is a real vector.
qlarfg.f:*  DLARFG generates a real elementary reflector H of order n, such
qlarfg.f:*  where alpha and beta are scalars, and x is an (n-1)-element real
qlarfg.f:*  where tau is a real scalar and v is a real (n-1)-element
qlarft.f:*  DLARFT forms the triangular factor T of a real block reflector H
qlascl.f:*  DLASCL multiplies the M by N real matrix A by the real scalar
qorg2r.f:*  DORG2R generates an m by n real matrix Q with orthonormal columns,
qorgqr.f:*  DORGQR generates an M-by-N real matrix Q with orthonormal columns,
qorm2r.f:*  DORM2R overwrites the general real m by n matrix C with
qorm2r.f:*  where Q is a real orthogonal matrix defined as the product of k
qormqr.f:*  DORMQR overwrites the general real M-by-N matrix C with
qormqr.f:*  where Q is a real orthogonal matrix defined as the product of k
qtgevc.f:*  a pair of real matrices (S,P), where S is a quasi-triangular matrix
qtgevc.f:*          computed.  If w(j) is a real eigenvalue, the corresponding
qtgevc.f:*          real eigenvector is computed if SELECT(j) is .TRUE..
qtgevc.f:*          If w(j) and w(j+1) are the real and imaginary parts of a
qtgevc.f:*          real part, and the second the imaginary part.
qtgevc.f:*          real part and the second the imaginary part.
qtgevc.f:*          is set to N.  Each selected real eigenvector occupies one
qtgevc.f:*     WORK( 2*N+1:3*N ) = real part of eigenvector
qtgevc.f:*     WORK( 4*N+1:5*N ) = real part of back-transformed eigenvector
qtgevc.f:*  are real). The equation to be solved is:
qtgevc.f:     $                   CIM2B, CIMAGA, CIMAGB, CRE2A, CRE2B, CREALA,
qtgevc.f:     $                   CREALB, DMIN, SAFMIN, SALFAR, SBETA, SCALE,
qtgevc.f:*           Decide if (a) singular pencil, (b) real eigenvalue, or
qtgevc.f:*              Real eigenvalue
qtgevc.f:*           Decide if (a) singular pencil, (b) real eigenvalue, or
qtgevc.f:*              Real eigenvalue
qtgevc.f:               CREALA = ACOEF*WORK( 2*N+JE-1 )
qtgevc.f:               CREALB = BCOEFR*WORK( 2*N+JE-1 ) -
qtgevc.f:                  WORK( 2*N+JR ) = -CREALA*S( JR, JE-1 ) +
qtgevc.f:     $                             CREALB*P( JR, JE-1 ) -
qtgevc.f:                        CREALA = ACOEF*WORK( 2*N+J+JA-1 )
qtgevc.f:                        CREALB = BCOEFR*WORK( 2*N+J+JA-1 ) -
qtgevc.f:     $                                      CREALA*S( JR, J+JA-1 ) +
qtgevc.f:     $                                      CREALB*P( JR, J+JA-1 )
qtgevc.f:                        CREALA = ACOEF*WORK( 2*N+J+JA-1 )
qtgevc.f:                        CREALB = BCOEFR*WORK( 2*N+J+JA-1 )
qtgevc.f:     $                                      CREALA*S( JR, J+JA-1 ) +
qtgevc.f:     $                                      CREALB*P( JR, J+JA-1 )
