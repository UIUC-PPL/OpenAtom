/** \file cpaimd.ci
 *
 */

mainmodule cpaimd {	
	readonly double Timer;
	readonly int nstates;
	readonly int sizeX;
	readonly int nchareG;
	readonly int Ortho_UE_step2;
	readonly int Ortho_UE_step3;
	readonly int Ortho_UE_error;
	readonly bool Ortho_use_local_cb;
	readonly int done_init;
	readonly int TimeKeeperID;
	readonly int numPes;
	readonly int planes_per_pe;
	readonly bool fakeTorus;
	readonly CProxy_TimeKeeper TimeKeeperProxy;
	readonly CkVec <CkGroupID> mCastGrpIds;
	initproc registersumFastDouble(void);	
	readonly  CProxy_OrthoMap orthoMap;
        extern module ckPairCalculator;
	extern module CLA_Matrix; 

	readonly CkHashtableT<intdual, int> GSmaptable;
	readonly CkHashtableT<intdual, int> RSmaptable;
	readonly CkHashtableT<intdual, int> RPPmaptable;
	readonly CkHashtableT<intdual, int> RhoGSmaptable;
	readonly CkHashtableT<intdual, int> RhoRSmaptable;
	readonly CkHashtableT<intdual, int> RhoGHartmaptable;
	readonly CkHashtableT<inttriple, int> RhoRHartmaptable;
	readonly CkHashtableT<intdual, int> Orthomaptable;
	readonly CkHashtableT<intdual, int> OrthoHelpermaptable;
	readonly CkHashtableT<intdual, int> AsymScalcmaptable;
	readonly CkHashtableT<intdual, int> SymScalcmaptable;

	readonly MapType2 GSImaptable;
	readonly MapType2 RSImaptable;
	readonly MapType2 RPPImaptable;
	readonly MapType2 RhoGSImaptable;
	readonly MapType2 RhoRSImaptable;
	readonly MapType2 RhoGHartImaptable;
	readonly MapType3 RhoRHartImaptable;
	readonly MapType2 OrthoImaptable;
	readonly MapType2 OrthoHelperImaptable;
	readonly MapType4 AsymScalcImaptable;
	readonly MapType4 SymScalcImaptable;


	readonly Config config;
	readonly PairCalcID pairCalcID1;
	readonly PairCalcID pairCalcID2;


	readonly CProxy_CP_State_GSpacePlane gSpacePlaneProxy;
	readonly CProxy_CP_State_ParticlePlane particlePlaneProxy;
	readonly CProxy_CP_State_RealSpacePlane realSpacePlaneProxy;
	readonly CProxy_CP_State_RealParticlePlane realParticlePlaneProxy;
	readonly CProxy_CP_Rho_RealSpacePlane rhoRealProxy;
	readonly CProxy_CP_Rho_GSpacePlane rhoGProxy;
	readonly CProxy_CP_Rho_GHartExt rhoGHartExtProxy;
	readonly CProxy_CP_Rho_RHartExt rhoRHartExtProxy;
	readonly CProxy_Ortho orthoProxy;
	readonly CProxy_OrthoHelper orthoHelperProxy;
	readonly CProxy_Lambda lambdaProxy;
	readonly CProxy_AtomsGrp atomsGrpProxy;
	readonly CProxy_CPcharmParaInfoGrp scProxy;
	readonly CProxy_EnergyGroup egroupProxy;
	readonly CProxy_FFTcache fftCacheProxy;
	readonly CProxy_StructFactCache sfCacheProxy;
	readonly CProxy_StructureFactor sfCompProxy;
	readonly CProxy_eesCache  eesCacheProxy;
	
	readonly CkGroupID mCastGrpId;

        // exc, hart, eext communication
	readonly ComlibInstanceHandle commGHartInstance;
	readonly ComlibInstanceHandle commGInstance0;
	readonly ComlibInstanceHandle commGInstance1;
	readonly ComlibInstanceHandle commGInstance2;
	readonly ComlibInstanceHandle commGInstance3;	
	readonly ComlibInstanceHandle commGByrdInstance;
	readonly ComlibInstanceHandle commRealInstance;
	readonly ComlibInstanceHandle commRealIGXInstance;
	readonly ComlibInstanceHandle commRealIGYInstance;
	readonly ComlibInstanceHandle commRealIGZInstance;

	//ortho to itself
	readonly ComlibInstanceHandle orthoInstance;

        // pc communication
	readonly ComlibInstanceHandle gAsymInstance;
	readonly ComlibInstanceHandle gSymInstance;

        // multicast for vks to states and other things
	readonly ComlibInstanceHandle mcastInstance;
	readonly ComlibInstanceHandle mcastInstancePP;
	readonly ComlibInstanceHandle mcastInstanceRPP;
	readonly ComlibInstanceHandle mcastInstancemRPP;

        // density from psi : g->r and r->g
	readonly ComlibInstanceHandle mssInstance;
	readonly ComlibInstanceHandle gssInstance;

        // Nonlocal Ees method : g->r and r->g
	readonly ComlibInstanceHandle gssPInstance;
	readonly ComlibInstanceHandle mssPInstance;

        // Eext method : g->r and r->g
	readonly ComlibInstanceHandle commRHartGHartIns;
	readonly ComlibInstanceHandle commGHartRHartIns0;
	readonly ComlibInstanceHandle commGHartRHartIns1;

        // PINY Physics readonly data structures
        readonly MDINTEGRATE  readonly_mdintegrate;
        readonly MDATOMS      readonly_mdatoms;
        readonly MDINTER      readonly_mdinter;
        readonly MDINTRA      readonly_mdintra;
        readonly GENERAL_DATA readonly_general_data;
        readonly CP           readonly_cp; 

	message PPDummyMsg;
	message CompAtmForcMsg {double zmat[];};
	message NLDummyMsg;
	message SFDummyMsg;
	message RSDummyResume;
	message GHartDummyMsg;

	message ProductMsg {double data[];};	
	message AtomMsg {double data[];};	
	
	message EnlCookieMsg;
	message orthoMtrigger;

	message initCookieMsg;

	message StructFactorMsg {
		complex structFactor[];
		complex structFactor_fx[];
		complex structFactor_fy[];
		complex structFactor_fz[];
	};
	
	message TMsg {complex data[];};
	
	message GSIFFTMsg {complex data[];};

	message GSPPIFFTMsg {complex data[];};

	message RSFFTMsg {complex data[];};

	message RPPPFFTMsg {complex data[];};

	message RhoGSFFTMsg {complex data[];};

	message RhoGHartMsg {complex data[];};

	message RhoRHartMsg {complex data[];};

	message RhoRSFFTMsg {complex data[];};

	message RhoHartRSFFTMsg {complex data[];};

	message GSRedPsiMsg {complex data[];};

	message GSAtmMsg;

	message GStateOutMsg {
		complex data[];
		complex vdata[];
		int k_x[];
		int k_y[];
		int k_z[];
	};

	message OrthoHelperMsg {
		double A[];
		double B[];
        };
	message NLFFTMsg {complex data[];};

	mainchare main {
		entry main();
	        entry void doneInit(CkReductionMsg *msg);
	};

	array [2D]  CP_State_GSpacePlane {
		entry CP_State_GSpacePlane(int sizeX, 
                        int numG, int numR, int s_grain, int numChunks, int timekeepf, int timekeepb);
		entry void initGSpace(int m, 
			complex pts[m],int mv, complex vpts[mv], 
                        int nx,int ny,int nz,int ngridaNL,int ngridbNL,int ngridcNL,
                        int istart_cp);
		entry void acceptIFFT(GSIFFTMsg *);
		entry [local] void doIFFT();
		entry void doFFT();
		entry void syncpsi();
		entry void receiveRDMAHandle(RDMAHandleMsg *msg);
                entry [nokeep] void acceptAtoms(GSAtmMsg *msg);
                entry [nokeep] void acceptEnergy(GSAtmMsg *msg);
                entry void collectFileOutput(GStateOutMsg *msg);
		entry void acceptNewPsi(CkReductionMsg *msg);	
		entry void acceptNewPsi(partialResultMsg *msg);	
		entry void acceptRedPsi(GSRedPsiMsg *msg);	
		entry [local] void doNewPsi();
		entry [local] void doNewPsiV();
		entry [local] void doLambda();
		entry void acceptLambda(CkReductionMsg *msg);
		entry void acceptLambda(partialResultMsg *msg);
		entry void acceptAllLambda(CkReductionMsg *msg);

		entry void acceptNewPsiV(CkReductionMsg *msg);
		entry void acceptNewPsiV(partialResultMsg *msg);
		entry void requirePsiV();
		entry void resumePsiV(CkReductionMsg *msg);
		entry void gdonePsiV(CkReductionMsg *msg);
		entry void gdonePsi(CkReductionMsg *msg);
                entry void acceptRedPsiV(GSRedPsiMsg *msg);

		entry void makePCproxies();
		entry void isAtSync(int);
		entry void startNewIter ();
		entry void startNLEes (bool ,int);
		entry void gdoneIFFT(CkReductionMsg *msg);

		entry void psiWriteComplete(CkReductionMsg *msg);
		entry void computeEnergies(int p, double d);
                entry void run ();
                entry void psiCgOvlap(CkReductionMsg *);
		entry void readFile();
		entry void combineForcesGetEke();	
	};
	
	array [2D] CP_State_ParticlePlane {
		entry CP_State_ParticlePlane(int ,int ,int ,int ,int ,int ,int ,
                                             int ,int ,int ,int ,int ,int ,int ,int);
		entry void computeZ(PPDummyMsg *dmsg);
		entry void reduceZ(int size, int atmIndex, complex zmatrix[size],
			complex zmatrix_fx[size], complex zmatrix_fy[size],
                        complex zmatrix_fz[size]);
		entry void getForces(int zsize, int atmIndex, complex zmat[zsize]);
		entry void lPrioStartNLEes(NLDummyMsg *m);
		entry [nokeep] void setEnlCookie(EnlCookieMsg *m);	
		entry void recvFromEesRPP(GSPPIFFTMsg  *m);
                entry void registrationDone(CkReductionMsg *msg);
	};

	// This is where the real component lives when using ees for nonlocal
	array [2D] CP_State_RealParticlePlane {
		entry CP_State_RealParticlePlane(int , int , int ,int , int ,int ,int,int);
	        entry void init();
                entry void recvFromEesGPP(NLFFTMsg *);
                entry void recvZMatEes(CkReductionMsg *);
                entry [nokeep] void computeAtmForcEes(CompAtmForcMsg *msg);

                entry [nokeep] void setPlaneRedCookie(EnlCookieMsg *);
                entry [nokeep] void setEnlCookie(EnlCookieMsg *);
                entry void registrationDone(CkReductionMsg *msg);
		entry void printEnlR(CkReductionMsg *);
		entry void printEnlRSimp(double ,int,int);
                entry void recvZMatEesSimp(int size, double _zmat[size],int state, 
                                           int index, int iterNL_in);
		entry [local] void FFTNLEesFwdR();
	        entry void launchFFTControl(int );
	};

	array [2D] CP_State_RealSpacePlane {
		entry CP_State_RealSpacePlane( int , int ,int, int, int,int, int);
		entry void acceptFFT(RSFFTMsg *);
		entry [local] void doFFT();
		entry [nokeep] void acceptProduct(ProductMsg *m);
		entry [local] void doVksFFT();
		entry void setNumPlanesToExpect(int num);
		entry void printData();
		entry void rdoneVks(CkReductionMsg *m);
		entry [nokeep] void init(ProductMsg *m);
	};

	array [2D] CP_Rho_RealSpacePlane {	
		entry CP_Rho_RealSpacePlane(int, bool,int,int, int);
		entry void init();
                entry void exitForDebugging();
		entry void acceptDensity(CkReductionMsg *m);
		entry void acceptGradRhoVks(RhoRSFFTMsg *msg);
                entry void acceptGradRhoVksAll(RhoRSFFTMsg *msg);
		entry void acceptWhiteByrd(RhoRSFFTMsg *msg);
		entry void acceptHartVks(RhoHartRSFFTMsg *msg);
	        entry void RHartReport();
		entry void isAtSync(int);
                entry void acceptRhoGradVksRyToGy(RhoGSFFTMsg *msg);
                entry void acceptRhoGradVksGxToRx(RhoGSFFTMsg *msg);
	};
       array [3D] CP_Rho_RHartExt {
                entry CP_Rho_RHartExt(int, int, int,int,int);
		entry void init();
                entry void startEextIter();
                entry void recvAtmForcFromRhoGHart(RhoRHartMsg *msg);
                entry void registrationDone(CkReductionMsg *msg);
                entry void recvAtmSfRyToGy(RhoGHartMsg *msg);
                entry void recvAtmForcGxToRx(RhoGHartMsg *msg);
                entry void exitForDebugging();
        }

	array [2D] CP_Rho_GSpacePlane {
		entry CP_Rho_GSpacePlane(int, int, int, bool);
		entry void init();
		entry void acceptRhoData(RhoGSFFTMsg *msg);
		entry void acceptWhiteByrd(RhoGSFFTMsg *msg);
                entry void acceptWhiteByrdAll(RhoGSFFTMsg *msg);
		entry void isAtSync(int);
		entry [local] void doRhoFFT();
                entry void exitForDebugging();
	};

	array [2D] CP_Rho_GHartExt {
		entry CP_Rho_GHartExt(int,int,int,int,int);
		entry void acceptData(RhoGHartMsg *msg);
		entry void init();
		entry void isAtSync(int);
		entry void recvAtmSFFromRhoRHart(RhoGHartMsg *msg);
		entry [local] void FFTEesBck();
                entry void registrationDone(CkReductionMsg *msg);
                entry void exitForDebugging();
                entry void acceptVks(int size, complex inVks[size]);
                entry void acceptAtmSFTot(int size, complex inSF[size]);
	};


	class CLA_Matrix_interface;

	array [2D] Ortho{
		entry void Ortho(int m, int n, CLA_Matrix_interface matA1,
		 CLA_Matrix_interface matB1, CLA_Matrix_interface matC1,
		 CLA_Matrix_interface matA2, CLA_Matrix_interface matB2,
		 CLA_Matrix_interface matC2, CLA_Matrix_interface matA3,
		 CLA_Matrix_interface matB3, CLA_Matrix_interface matC3,
	         int timekeep
         	);
		entry Ortho();
		entry void acceptAllLambda(CkReductionMsg *msg);
		entry void acceptSectionLambda(CkReductionMsg *msg);
		entry void resume();
		entry void resumeV(CkReductionMsg *msg);
		entry void maxCheck(CkReductionMsg *msg);
		entry void lbresume(CkReductionMsg *msg);
		entry void makeSections(int indexSize, int indexZ[indexSize]);
		entry void setPCproxy(CProxySection_PairCalculator inproxy);
		entry void start_calc(CkReductionMsg *msg);	
		entry void orthoCookieinit(initCookieMsg *msg);
		entry void do_iteration();
		entry [nokeep] void do_iteration(orthoMtrigger *msg);
		entry void step_2();
		entry void step_3();	
		entry void recvStep2(double result[size], int size);
		entry void collect_results();
		entry [nokeep] void collect_results(orthoMtrigger *msg);
		entry void print_results();
  		entry void collect_error(CkReductionMsg *msg);
		entry void ready();
		entry void all_ready();
		entry void sendOrthoTtoAsymm();
      };

	group OrthoMap : CkArrayMap {
		entry OrthoMap();
	};

	array [2D] OrthoHelper {
		entry void OrthoHelper(int m, int n, CLA_Matrix_interface matA2,
		 CLA_Matrix_interface matB2, CLA_Matrix_interface matC2);
		entry OrthoHelper();
	        entry void recvAB(OrthoHelperMsg *msg);

	}
	
	group OrthoHelperMap : CkArrayMap {
		entry OrthoHelperMap();
	};

	array [2D] Lambda{
		entry void Lambda(int lgrain, int ograin, int sgrain);
		entry Lambda();
		entry void acceptAllLambda(CkReductionMsg *msg);
		entry void acceptSectionLambda(CkReductionMsg *msg);
		entry void makeSections(int indexSize, int indexZ[indexSize]);
	      };

	group LambdaMap : CkArrayMap {
		entry LambdaMap(int M,int nLambda, int stride);
	};


	group RhoGSMap : CkArrayMap {
		entry RhoGSMap();
	};

	group RhoRSMap : CkArrayMap {
		entry RhoRSMap();
	};

	group RhoGHartMap : CkArrayMap {
		entry RhoGHartMap();
	};

	group RhoRHartMap : CkArrayMap {
		entry RhoRHartMap();
	};
        
	group GSMap : CkArrayMap {
		entry GSMap();
	};
	
	group RPPMap : CkArrayMap {
		entry RPPMap();
	};


	group RSMap : CkArrayMap {
		entry RSMap();
	};
	
	group SCalcMap: CkArrayMap {
		entry SCalcMap(bool);
	};

	/** 
	  *  A place to hold the fftw plans or sizes for essl.
	  *  Preallocated space for ffts some of which retain their data  
	  *  across entry method calls.  Does no messaging.
	  */	
	group FFTcache {
		entry FFTcache( int , int , int , int , int , int , 
                   int , int , int , int , int , int , int ,
                   int nchareGState, int nchareRState,
                   int nchareGNL,    int nchareRNL, 
                   int nchareGRho,   int nchareRRho,  int nchareRRhoTot,
                   int nchareGEext,  int nchareREext, int nchareREextTot,
                   int numGState[nchareGState],   
                   int numRXState[nchareRState], 
                   int numRYState[nchareRState],
                   int numGNL[nchareGNL],      
                   int numRXNL[nchareRNL],
                   int numRYNL[nchareRNL],
                   int numGRho[nchareGRho],    
                   int numRXRho[nchareRRhoTot],  
                   int numRYRho[nchareRRhoTot],
                   int numGEext[nchareGEext],    
                   int numRXEext[nchareREextTot],  
                   int numRYEext[nchareREextTot],
                   int ,  int ,  int , int );
	};

	/** Place to hold the computed structure factor.
	  * 
	  */ 
	group StructFactCache {
		entry void acceptStructFact(StructFactorMsg *msg);

		entry StructFactCache(int numSfGrps,int natm_nl,int natm_nl_grp_max);
	};

	// This is what is used if NOT using ees for nonlocal structure factor comp
        array [3D] StructureFactor { 
	        entry StructureFactor(int, int, int,int nsend, int destinations[nsend]);
	        entry void acceptDestination(int nsend, int destinations[nsend]);
         	entry void computeSF(SFDummyMsg *msg);
		entry void acceptKVectors(int n, int k_x[n], int k_y[n], int k_z[n]);
	};

	// various chares use CkLocal to access the atoms:
	// Rho_RHart RhoGHart StructureFactor RealParticlePlane
	// ParticlePlane RealSpacePlane GSpacePlane  
	// EJB: this could perhaps be better implemented in an MSA
	group AtomsGrp {
		entry AtomsGrp(int natm, int natm_nl,int len_nhc,
                               int iextended_on,int cp_min_opt,int cp_wave_opt,
                               int isokin_opt,
                               double kT,Atom atoms[natm],AtomNHC atomsNHC[natm]);


	     /** trigger force computation 	
		* based on real forces available in each processor's chare	
		* then contribute to global group reduction -> recvContribute
		*/
                entry void StartRealspaceForces();  	

	     /*** 
		* Apply forces to each processor's copy of the atoms.
		* This is parallelized so that a subset of the atoms
		* are computed on each processor and their results broadcast
		* to AtmGroup->acceptAtoms().
		* Move the atoms each processor is responsible
                * for. Set various energyGroup members.
		* contribute to group reduction ->atomsDone
		*/	
                entry void recvContribute(CkReductionMsg *);


	     /***
		* Increment the iteration counters in atoms and eesData
		* call gSpacePlane()->acceptAtoms 
		* That is done via localbranch to all co-located gSpacePlanes
		* in the localBarrier scheme.  Used to be via messages.
		* This permits the new step to advance with the new Psi.
		*/
                entry void atomsDone(CkReductionMsg *);

	     /***
	        * Take packed message of a chunk of the atoms with
	        * updated positions. Update local copy of atoms.
		* Update local energyGroup members.
		* Print atom energies when we have all of them.   		
		* Do file output of atoms if desired.
		*/
                entry void acceptAtoms(AtomMsg *);
	};

	// The physics configuration, both input, and derived, is kept
	// here.  This data is effectively readonly.
	group CPcharmParaInfoGrp {
		entry CPcharmParaInfoGrp(CPcharmParaInfo &s);
	};

	// The global energies are stored here.
	group EnergyGroup {
		entry EnergyGroup();
		/***
		   * CP_StateGspacePlane(0,0) calls this to replicate the 
		   * energies everywhere for consistency and tolerance
		   * checking.
		   */
		entry void updateEnergiesFromGS(EnergyStruct es);
		/***
		   * call CP_StateGSpacePlane()->acceptEnergy
		   * on all co-located gspace chares which allows
		   * the new step to advance with new psi			
		   */
                entry void energyDone(CkReductionMsg *);
	};

	/** 
	  *  A place to hold the computed ees planewise data on each proc
	  */	
	group eesCache {
		entry eesCache(int,int,int,int,int,int);
	};
	
	chare TimeKeeper {
		entry TimeKeeper();
		entry void init();
	        entry void collectStart(CkReductionMsg *m);	  
	        entry void collectEnd(CkReductionMsg *m);	  
	};
};
