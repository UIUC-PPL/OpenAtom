module gSpaceDriver
{
    include "uber/Uber.h";
	array [2D] GSpaceDriver
	{
		// Constructor(s)
		entry GSpaceDriver(const UberCollection _thisInstance);
		
		// Temp SDAG method for RTH to SDAG translation
		entry void driveGSpace() {
			// (I) Starts here
			while(myGSpaceObj->cleanExitCalled!=1) {
				serial {
					tempFlag = (CPcharmParaInfo::get()->cp_min_opt==1 && CPcharmParaInfo::get()->gen_wave==0) || isFirstStep == false;
				}
				if (tempFlag) {
					serial {
						isEnergyReductionDone = false;
						isAtomIntegrationDone = false;
					}
// (A) ////////
#ifndef _CP_DEBUG_PSI_OFF_
					serial {
						myGSpaceObj->thisProxy(thisIndex.x,thisIndex.y).startNewIter();
					}
// (A.1) //////
// releaseSFComputeZ() will send messages to compute non-local forces, which will
// eventually result in a doneNLForces() message being sent to this chare.
#ifndef _CP_DEBUG_SFNL_OFF_
					if (ees_nonlocal==0 && natm_nl!=0) {
						serial {
							releaseSFComputeZ();
						}
#ifdef BARRIER_CP_PARTICLE_PLANE_NONLOCAL
						when allDoneNLForces(CkReductionMsg *msg) serial { areNLForcesDone = true; }
#endif
					}

#endif
// (A.2) //////
// Do FFT and IFFT computations. The FFT communications will require non-local forces to
// be computed if ees_nonlocal==1. If we don't do FFT/IFFT computations, we still need
// to do the nonlocal forces if ees_nonlocal==1.
#ifndef _CP_DEBUG_VKS_OFF_
					serial {
						myGSpaceObj->thisProxy(thisIndex.x, thisIndex.y).doFFT();
						myGSpaceObj->sendFFTData();
					}
					when receivedIFFT() serial {
						myGSpaceObj->thisProxy(thisIndex.x, thisIndex.y).doIFFT();
					}

#ifdef BARRIER_CP_GSPACE_IFFT
					when allDoneIFFT(CkReductionMsg *msg) serial { myGSpaceObj->doneDoingIFFT = true; }
#endif

#else
#ifndef _CP_DEBUG_SFNL_OFF_
					if (ees_nonlocal==1 && natm_nl!=0) serial {
						startNonLocalEes(myGSpaceObj->iteration);
					}
#endif
					serial {
						myGSpaceObj->doneDoingIFFT = true;
					}
#endif	// _CP_DEBUG_VKS_OFF_

// (A.3) //////
// Here we catch doneNLForces messages. One will be produced by (A.1) if ees_nonlocal==0.
// Otherwise, one will be produced in (A.2). We only wait for the message if
// areNLForcesDone hasn't already been set previously (ie: by the debug barrier).
#ifndef _CP_DEBUG_SFNL_OFF_
					if (!areNLForcesDone) {
#ifdef BARRIER_CP_PARTICLE_PLANE_NONLOCAL
						when allDoneNLForces(CkReductionMsg *msg) serial { areNLForcesDone = true; }
#else
						when doneNLForces() serial { areNLForcesDone = true; }
#endif
					}
#endif

// (A.4) //////
// Here we ensure that the IFFT has completed before moving on.
#ifndef _CP_DEBUG_VKS_OFF_
					if (!myGSpaceObj->doneDoingIFFT) {
						when doneIFFT() serial { myGSpaceObj->doneDoingIFFT = true; }
					}
#endif

					serial {
						myGSpaceObj->combineForcesGetEke();
					}
#endif	// _CP_DEBUG_PSI_OFF_

					serial {
						myGSpaceObj->launchAtoms();
					}				

// (B) ////////
#ifndef _CP_DEBUG_PSI_OFF_
					serial {
						if (natm_nl!=0) {
							// Reset this flag for the next step. Other flags are reset in myGSpaceObj::sendLambda()
							areNLForcesDone = false;
						}
						//myGSpaceObj->sendLambda();
						CkPrintf("%d\n", __LINE__);
						myGSpaceObj->blockB();
					} when doneBlockB() serial {}
/*#ifndef _CP_DEBUG_ORTHO_OFF_
					when doneLambda() {}
#endif
					serial {
						myGSpaceObj->computeCgOverlap();
					}
					when doneComputingCgOverlap() serial {
						tempFlag = config.stateOutput==1 && CPcharmParaInfo::get()->cp_min_opt!=0 && myGSpaceObj->iteration > 1;
					}
					if (tempFlag) {
						serial {
							tempFlag = (myGSpaceObj->iteration-1)%CPcharmParaInfo::get()->ndump_frq==0 || myGSpaceObj->iteration==config.maxIter || myGSpaceObj->outputFlag==1;
						}
						if (tempFlag) {
							serial {
								myGSpaceObj->writeStateDumpFile();
							}
							when allDoneWritingPsi(CkReductionMsg *msg) {}
						}
					}
					serial {
						myGSpaceObj->integrateModForce();
						myGSpaceObj->sendRedPsi();
					}
					if (myGSpaceObj->iRecvRedPsi==0) {
						// To avoid a race, iRecvRedPsi needs to be set here, rather than in myGSpaceObj::acceptRedPsi()
						when receivedRedPsi() serial { myGSpaceObj->iRecvRedPsi = 1; }
					}
					serial {
						myGSpaceObj->doneRedPsiIntegrate();
					}*/
#endif	//_CP_DEBUG_PSI_OFF_
				}
				// (II) Starts here
#ifndef _CP_DEBUG_PSI_OFF_
				serial {
					bool updateNeeded = CPcharmParaInfo::get()->cp_min_opt && myGSpaceObj->iteration > 1 && myGSpaceObj->iteration <= config.maxIter && isPsiVupdateNeeded;
					myGSpaceObj->blockC(updateNeeded);
				} when doneBlockC() serial { isPsiVupdateNeeded = false; }
				/*serial {
					myGSpaceObj->sendPsi();
				}
#ifndef _CP_DEBUG_ORTHO_OFF_
#ifdef BARRIER_CP_GSPACE_PSI
				when allDonePsi(CkReductionMsg *msg) {}
#else
				when donePsi() {}
#endif
#endif
				serial {
					tempFlag = config.stateOutput==1 && CPcharmParaInfo::get()->cp_min_opt==1 && myGSpaceObj->iteration > 0;
				}
				if (tempFlag) {
					serial {
						tempFlag = myGSpaceObj->iteration % CPcharmParaInfo::get()->ndump_frq==0 || myGSpaceObj->iteration==config.maxIter || myGSpaceObj->exitFlag==1;
					}
					if (tempFlag) {
						serial {
							myGSpaceObj->writeStateDumpFile();
						}
						when allDoneWritingPsi(CkReductionMsg *msg) {}
					}
				}
				serial {
					tempFlag = CPcharmParaInfo::get()->cp_min_opt==0 && myGSpaceObj->iteration > 1 && myGSpaceObj->iteration <= config.maxIter;
				}
				if (tempFlag) {
					if (isPsiVupdateNeeded) {
						serial {
							myGSpaceObj->acceptedVPsi = false;
							myGSpaceObj->sendRedPsiV();
						}
						if (myGSpaceObj->iRecvRedPsiV==0) {
							// To avoid a race, iRecvRedPsiV needs to be set here, rather than in myGSpaceObj::acceptRedPsiV()
							when receivedRedPsiV() serial { myGSpaceObj->iRecvRedPsiV = 1; }
						}
						serial {
							myGSpaceObj->doneRedPsiVIntegrate();
							myGSpaceObj->sendPsiV();
						}
#ifdef BARRIER_CP_GSPACE_PSIV
						when allDonePsiV(CkReductionMsg *msg) serial { isPsiVupdateNeeded = false; }
#else
						when donePsiV() serial { isPsiVupdateNeeded = false; }
#endif
					}
				}*/
#endif
				overlap {
#ifndef _CP_DEBUG_PSI_OFF
					when doneComputingEnergy(const int AtomGrpIter) serial { finishEnergy(AtomGrpIter); }
#endif
					when doneMovingAtoms(const int AtomsGrpIter) serial { finishAtoms(AtomsGrpIter); }
				}

				serial {
					isFirstStep = false;
				}
			}
		};

		// Create, invoke, resume, and kill RTH threads
		entry void startControl();
		//entry [local] void resumeControl();
		entry [local] void readyToExit();
		
		// Requests to trigger things
		entry void needUpdatedPsiV();
		entry void startNonLocalEes(int iteration_loc);
		
		// Incoming notifications of task completion
		entry void receivedIFFT();
		//entry void receivedRedPsi();
		//entry void receivedRedPsiV();
		entry void doneComputingEnergy(const int AtomGrpIter);
		entry void doneMovingAtoms(const int AtomGrpIter);
		//entry void doneComputingCgOverlap();
		//entry void doneLambda();
		//entry void donePsi();
		//entry void donePsiV();
		entry void doneNLForces();
		entry void doneIFFT();
		entry void doneBlockB();
		entry void doneBlockC();
		
		// Incoming reduction barrier notifications
#ifdef BARRIER_CP_GSPACE_PSI
		entry [nokeep] void allDonePsi(CkReductionMsg *msg);
#endif
#ifdef BARRIER_CP_GSPACE_PSIV
		entry [nokeep] void allDonePsiV(CkReductionMsg *msg);
#endif
		entry [nokeep] void allDoneWritingPsi(CkReductionMsg *msg) {};
#ifdef BARRIER_CP_GSPACE_IFFT
		entry [nokeep] void allDoneIFFT(CkReductionMsg *msg);
#endif
#ifdef BARRIER_CP_PARTICLEPLANE_NONLOCAL
		entry [nokeep] void allDoneNLForces(CkReductionMsg *msg);
#endif
	};
};



	
module gParticlePlane
{
	class UberCollection;
	class PPDummyMsg;
	
	message NLDummyMsg;
	message EnlCookieMsg;
	message GSPPIFFTMsg {complex data[];};
	
	array [2D] CP_State_ParticlePlane 
	{
		entry CP_State_ParticlePlane(int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int, UberCollection);
		entry void launchComputeZs();
		entry void computeZ(PPDummyMsg *dmsg);
		entry void reduceZ(int size, int atmIndex, complex zmatrix[size],complex zmatrix_fx[size], complex zmatrix_fy[size],complex zmatrix_fz[size]);
		entry void getForces(int zsize, int atmIndex, complex zmat[zsize]);
		entry void lPrioStartNLEes(NLDummyMsg *m);
		entry [nokeep] void setEnlCookie(EnlCookieMsg *m);	
		entry void recvFromEesRPP(GSPPIFFTMsg  *m);
		entry void registrationDone(CkReductionMsg *msg);
		entry void printEnl(CkReductionMsg *msg);
	};
};




module gStatePlane
{
    extern module pcMessages;
    extern module instanceController;

	extern module RDMAMessages;
	class RDMApair_GSP_PC;
    class pcSetupMsg;
	message RDMASetupRequestMsg<RDMApair_GSP_PC>;
	message RDMASetupConfirmationMsg<RDMApair_GSP_PC>;
						// TODO: Do we need to catch another doneNLForces message()?
	message RSFFTMsg     { complex data[]; };
	message GSIFFTMsg    { complex data[]; };
	message GSRedPsiMsg  { complex data[]; };
	message GStateOutMsg 
	{
		complex data[];
		complex vdata[];
		int k_x[];
		int k_y[];
		int k_z[];
	};

	class UberCollection;
    include "paircalc/pcFwdDeclarations.h";
    include "load_balance/PeList.h";

	array [2D]  CP_State_GSpacePlane 
	{
		entry CP_State_GSpacePlane(int sizeX, int numG, int numR, int s_grain, int timekeepf, int timekeepb, UberCollection);
        entry void acceptPairCalcAIDs(pcSetupMsg *msg);
		entry void initGSpace(int m, complex pts[m], int mv, complex vpts[mv], int nx,int ny,int nz,int ngridaNL,int ngridbNL,int ngridcNL, int istart_cp);
		entry void acceptIFFT(GSIFFTMsg *);
		entry [local] void doIFFT();
		entry [local] void doFFT();
		entry void completeRDMAhandshake(RDMASetupConfirmationMsg<RDMApair_GSP_PC> *msg);
		entry void collectFileOutput(GStateOutMsg *msg);
		entry void acceptNewPsi(CkReductionMsg *msg);	
		entry void acceptNewPsi(partialResultMsg *msg);	
		entry void acceptRedPsi(GSRedPsiMsg *msg);	
		entry [local] void doNewPsi();
		entry [local] void doNewPsiV();
		// TODO: Refactor out done methods
		// TODO: Add in barriers
		entry [local] void doneCgOverlap();
		entry void acceptLambda(CkReductionMsg *msg);
		entry void acceptLambda(partialResultMsg *msg);

		entry void acceptNewPsiV(CkReductionMsg *msg);
		entry void acceptNewPsiV(partialResultMsg *msg);
		entry void acceptRedPsiV(GSRedPsiMsg *msg);

		entry void makePCproxies();
		entry [local] void startNewIter ();

		entry void computeEnergies(int p, double d);
		entry void psiCgOvlap(CkReductionMsg *);
		entry void acceptNewTemperature(double temp);
		entry void readFile();
		entry [nokeep] void initBeadCookie(ICCookieMsg *msg);
		entry [nokeep] void minimizeSync(ICCookieMsg *msg);
		entry void setExitFlag();

// SDAG ////////
		entry void blockB() {
			serial { sendLambda(); }
#ifndef CP_DEBUG_ORTHO_OFF_
			while (countLambda != AllLambdaExpected) {
				case {
					when acceptLambda(CkReductionMsg *msg) serial { unpackLambda(msg); }
					when acceptLambda(partialResultMsg *msg) serial { unpackLambda(msg); }
				}
			}
			serial { doLambda(); }
#endif
			serial { computeCgOverlap(); }
			when doneCgOverlap() serial {
				//writeStateDumpFile();
				integrateModForce();
				sendRedPsi();
			}
			while (iRecvRedPsi == 0) {
				when acceptRedPsi(GSRedPsiMsg *msg) serial { unpackRedPsi(msg); }
			}
			serial {
				doneRedPsiIntegrate();
				UgSpaceDriverProxy[thisInstance.proxyOffset](thisIndex.x,thisIndex.y).doneBlockB();
			}
		};

		entry void blockC(bool isPsiVupdateNeeded) {
			serial { sendPsi(); }
#ifndef CP_DEBUG_ORTHO_OFF_
			while (countPsi != AllPsiExpected) {
				case {
					when acceptNewPsi(CkReductionMsg *msg) serial { unpackNewPsi(msg); }
					when acceptNewPsi(partialResultMsg *msg) serial { unpackNewPsi(msg); }
				}
			}
			serial { doNewPsi(); }
#endif
			serial {
				//writeStateDumpFile();
			}
			if (isPsiVupdateNeeded) {
				serial {
					acceptedVPsi = false;
					sendRedPsiV();
				}
				while (iRecvRedPsiV == 0) {
					when acceptRedPsiV(GSRedPsiMsg *msg) serial { unpackRedPsiV(msg); }
				}
				serial {
					doneRedPsiIntegrate();
					sendPsiV();
				}
				while (countVPsi != AllPsiExpected) {
					case {
						when acceptNewPsiV(CkReductionMsg *msg) serial { unpackNewPsiV(msg); }
						when acceptNewPsiV(partialResultMsg *msg) serial { unpackNewPsiV(msg); }
					}
				}
				serial { doNewPsiV(); }
			}
			serial {
				UgSpaceDriverProxy[thisInstance.proxyOffset](thisIndex.x,thisIndex.y).doneBlockC();
			}
		};
	};
};
