module gSpaceDriver
{
    include "uber/Uber.h";
	array [2D] GSpaceDriver
	{
		// Constructor(s)
		entry GSpaceDriver(const UberCollection _thisInstance);
		
		// Temp SDAG method for RTH to SDAG translation
		entry void run() {
			// (I) Starts here
			while(1) {
			serial {
				tempFlag = (CPcharmParaInfo::get()->cp_min_opt==1 && CPcharmParaInfo::get()->gen_wave==0) || isFirstStep == false;
			}
			if (tempFlag) {
				serial {
					isEnergyReductionDone = false;
					isAtomIntegrationDone = false;
#ifndef _CP_DEBUG_PSI_OFF_
					myGSpaceObj->thisProxy(thisIndex.x,thisIndex.y).startNewIter();
				}
#ifndef _CP_DEBUG_SFNL_OFF_
				serial {
					tempFlag = ees_nonlocal==0 && CPcharmParaInfo::get()->natm_nl!=0;
				}
				if (tempFlag) {
					serial {
						releaseSFComputeZ();
					}
#ifdef BARRIER_CP_PARTICLEPLANE_NONLOCAL
					//when doneNLForces(); // or allDoneNLForces(); ... use a case block
					when resumeControl() {}
#endif
				}
#endif	// _CP_DEBUG_SFNL_OFF_

#ifndef _CP_DEBUG_VKS_OFF_
				serial {
					myGSpaceObj->thisProxy(thisIndex.x, thisIndex.y).doFFT();
					myGSpaceObj->sendFFTData();
				}
				when resumeControl() {}
				
				serial {
					myGSpaceObj->thisProxy(thisIndex.x, thisIndex.y).doIFFT();
				}
#ifdef BARRIER_CP_GSPACE_IFFT
				//when allDoneIFFT();
				when resumeControl() {}
#endif

#else
#ifndef _CP_DEBUG_SFNL_OFF_
				serial {
					tempFlag = ees_nonlocal==1 && CPcharmParaInfo::get()->natm_nl!=0;
				}
				if (tempFlag) {
					startNonLocalEes(myGSpaceObj->iteration);
				}
#endif
				serial {
					myGSpaceObj->doneDoingIFFT = true;
				}
#endif	// _CP_DEBUG_VKS_OFF_

#ifndef _CP_DEBUG_SFNL_OFF
				if (!areNLForcesDone) {
					// when doneNLForces() or allDoneNLForces()
					when resumeControl() {}
				}
#endif
				serial {
					myGSpaceObj->combineForcesGetEke();
				}

				serial {
#endif	// _CP_DEBUG_PSI_OFF_
					myGSpaceObj->launchAtoms();
				}				

#ifndef _CP_DEBUG_PSI_OFF_
				serial {
					tempFlag = CPcharmParaInfo::get()->natm_nl!=0;
				}
				if (tempFlag) serial {
					areNLForcesDone = false;
				}
				serial {
					myGSpaceObj->sendLambda();
				}
#ifndef _CP_DEBUG_ORTHO_OFF_
				when resumeControl() {}
#endif
				serial {
					myGSpaceObj->computeCgOverlap();
				}
				when resumeControl() {}
				
				serial {
					tempFlag = config.stateOutput==1 && CPcharmParaInfo::get()->cp_min_opt!=0 && myGSpaceObj->iteration > 1;
				}
				if (tempFlag) {
					serial {
						tempFlag = (myGSpaceObj->iteration-1)%CPcharmParaInfo::get()->ndump_frq==0 || myGSpaceObj->iteration==config.maxIter || myGSpaceObj->outputFlag==1;
					}
					if (tempFlag) {
						serial {
							myGSpaceObj->writeStateDumpFile();
						}
						//when allDoneWritingPsi()
						when resumeControl() {}
					}
				}
				serial {
					myGSpaceObj->integrateModForce();
					myGSpaceObj->sendRedPsi();
				}
				serial {
					tempFlag = myGSpaceObj->iRecvRedPsi==0;
				}
				if (myGSpaceObj->iRecvRedPsi==0) {
					when resumeControl() {}
				}
				serial {
					myGSpaceObj->doneRedPsiIntegrate();
				}
#endif	//_CP_DEBUG_PSI_OFF_
			}
			// (II) Starts here
#ifndef _CP_DEBUG_PSI_OFF_
			serial {
				myGSpaceObj->sendPsi();
			}
#ifndef _CP_DEBUG_ORTHO_OFF_
			when resumeControl() {}
#endif
			serial {
				tempFlag = config.stateOutput==1 && CPcharmParaInfo::get()->cp_min_opt==1 && myGSpaceObj->iteration > 0;
			}
			if (tempFlag) {
				serial {
					tempFlag = myGSpaceObj->iteration % CPcharmParaInfo::get()->ndump_frq==0 || myGSpaceObj->iteration==config.maxIter || myGSpaceObj->exitFlag==1;
				}
				if (tempFlag) {
					serial {
						myGSpaceObj->writeStateDumpFile();
					}
					when resumeControl() {}
				}
			}
			serial {
				tempFlag = CPcharmParaInfo::get()->cp_min_opt==0 && myGSpaceObj->iteration > 1 && myGSpaceObj->iteration <= config.maxIter;
			}
			if (tempFlag) {
				if (isPsiVupdateNeeded) {
					serial {
						myGSpaceObj->acceptedVPsi = false;
						myGSpaceObj->sendRedPsiV();
					}
					if (myGSpaceObj->iRecvRedPsiV==0) {
						when resumeControl() {}
					}
					serial {
						myGSpaceObj->doneRedPsiVIntegrate();
						myGSpaceObj->sendPsiV();
					}
					when resumeControl() {}
					serial {
						isPsiVupdateNeeded = false;
					}
				}
			}
			if (isEnergyReductionDone==false && myGSpaceObj->iteration>0) serial {
				waitingForEnergy = true;
			}
#endif	// _CP_DEBUG_PSI_OFF
			if (isAtomIntegrationDone==false && myGSpaceObj->iteration>0) serial {
				waitingForAtoms = true;
			}
			if (waitingForAtoms || waitingForEnergy) {
#ifdef _CP_DEBUG_WARN_SUSPEND_
				serial {
					CkPrintf("GSpace[%d,%d] Suspending atm/energy on proc %d : atom:%d energy:%d\n", thisIndex.x, thisIndex.y, CkMyPe(), waitingForAtoms, waitingForEnergy);
				}
#endif
				when resumeControl() {}
			}
			if (myGSpaceObj->cleanExitCalled==1) {
				when resumeControl() {}
			}
			serial {
				isFirstStep = false;
			}
			}
		};

		// Create, invoke, resume, and kill RTH threads
		entry void startControl();
		entry [local] void resumeControl();
		entry [local] void readyToExit();
		
		// Requests to trigger things
		entry void needUpdatedPsiV();
		entry void startNonLocalEes(int iteration_loc);
		
		// Incoming notifications of task completion
		entry [local] void doneComputingEnergy(const int AtomsGrpIter);
		entry [local] void doneMovingAtoms(const int AtomsGrpIter);
		entry [local] void doneNLForces();
		
		// Incoming reduction barrier notifications
		entry void allDonePsi(CkReductionMsg *msg);
		entry void allDoneWritingPsi(CkReductionMsg *msg);
		entry void allDonePsiV(CkReductionMsg *msg);
		entry void allDoneIFFT(CkReductionMsg *msg);
		entry void allDoneNLForces(CkReductionMsg *msg);
	};
};



	
module gParticlePlane
{
	class UberCollection;
	class PPDummyMsg;
	
	message NLDummyMsg;
	message EnlCookieMsg;
	message GSPPIFFTMsg {complex data[];};
	
	array [2D] CP_State_ParticlePlane 
	{
		entry CP_State_ParticlePlane(int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int, UberCollection);
		entry void launchComputeZs();
		entry void computeZ(PPDummyMsg *dmsg);
		entry void reduceZ(int size, int atmIndex, complex zmatrix[size],complex zmatrix_fx[size], complex zmatrix_fy[size],complex zmatrix_fz[size]);
		entry void getForces(int zsize, int atmIndex, complex zmat[zsize]);
		entry void lPrioStartNLEes(NLDummyMsg *m);
		entry [nokeep] void setEnlCookie(EnlCookieMsg *m);	
		entry void recvFromEesRPP(GSPPIFFTMsg  *m);
		entry void registrationDone(CkReductionMsg *msg);
		entry void printEnl(CkReductionMsg *msg);
	};
};




module gStatePlane
{
    extern module pcMessages;
    extern module instanceController;

	extern module RDMAMessages;
	class RDMApair_GSP_PC;
    class pcSetupMsg;
	message RDMASetupRequestMsg<RDMApair_GSP_PC>;
	message RDMASetupConfirmationMsg<RDMApair_GSP_PC>;
	message RSFFTMsg     { complex data[]; };
	message GSIFFTMsg    { complex data[]; };
	message GSRedPsiMsg  { complex data[]; };
	message GStateOutMsg 
	{
		complex data[];
		complex vdata[];
		int k_x[];
		int k_y[];
		int k_z[];
	};

	class UberCollection;
    include "paircalc/pcFwdDeclarations.h";
    include "load_balance/PeList.h";

	array [2D]  CP_State_GSpacePlane 
	{
		entry CP_State_GSpacePlane(int sizeX, int numG, int numR, int s_grain, int timekeepf, int timekeepb, UberCollection);
        entry void acceptPairCalcAIDs(pcSetupMsg *msg);
		entry void initGSpace(int m, complex pts[m], int mv, complex vpts[mv], int nx,int ny,int nz,int ngridaNL,int ngridbNL,int ngridcNL, int istart_cp);
		entry void acceptIFFT(GSIFFTMsg *);
		entry [local] void doIFFT();
		entry [local] void doFFT();
		entry void completeRDMAhandshake(RDMASetupConfirmationMsg<RDMApair_GSP_PC> *msg);
		entry void collectFileOutput(GStateOutMsg *msg);
		entry void acceptNewPsi(CkReductionMsg *msg);	
		entry void acceptNewPsi(partialResultMsg *msg);	
		entry void acceptRedPsi(GSRedPsiMsg *msg);	
		entry [local] void doNewPsi();
		entry [local] void doNewPsiV();
		entry [local] void doLambda();
		entry void acceptLambda(CkReductionMsg *msg);
		entry void acceptLambda(partialResultMsg *msg);

		entry void acceptNewPsiV(CkReductionMsg *msg);
		entry void acceptNewPsiV(partialResultMsg *msg);
		entry void acceptRedPsiV(GSRedPsiMsg *msg);

		entry void makePCproxies();
		entry [local] void startNewIter ();

		entry void computeEnergies(int p, double d);
		entry void psiCgOvlap(CkReductionMsg *);
		entry void acceptNewTemperature(double temp);
		entry void readFile();
		entry [nokeep] void initBeadCookie(ICCookieMsg *msg);
		entry [nokeep] void minimizeSync(ICCookieMsg *msg);
		entry void setExitFlag();

	};
};
