#ifdef _CP_DEBUG_PSI_OFF_
#define _SDAG_DEBUG_PSI_OFF_ true
#else
#define _SDAG_DEBUG_PSI_OFF_ false
#endif

#ifdef _CP_DEBUG_SFNL_OFF_
#define _SDAG_DEBUG_SFNL_OFF_ true
#else
#define _SDAG_DEBUG_SFNL_OFF_ false
#endif

#ifdef _CP_DEBUG_VKS_OFF_
#define _SDAG_DEBUG_VKS_OFF_ true
#else
#define _SDAG_DEBUG_VKS_OFF_ false
#endif

#ifdef _CP_DEBUG_ORTHO_OFF_
#define _SDAG_DEBUG_ORTHO_OFF_ true
#else
#define _SDAG_DEBUG_ORTHO_OFF_ false
#endif

module gSpaceDriver
{
    include "uber/Uber.h";
	array [2D] GSpaceDriver
	{
		// Constructor(s)
		entry GSpaceDriver(const UberCollection _thisInstance);

		// Start and stop the flow control using SDAG
		entry void startControl();
		entry [local] void readyToExit();
		
		// Requests to trigger things
		entry void needUpdatedPsiV();
		entry void startNonLocalEes(int iteration_loc);
		
		// Incoming notifications of task completion
		entry void doneComputingEnergy(const int AtomGrpIter);
		entry void doneMovingAtoms(const int AtomGrpIter);
		entry void donePsiFandVKS();
		entry void doneLambdaAndCgAndRedPsi();
		entry void doneNewPsiAndPsiV();
		entry void doneNLForces();

		// Incoming reduction barrier notifications
		entry [nokeep] void allDoneNLForces(CkReductionMsg *msg) { serial { doneNLForces(); } };
		
		// SDAG method for flow control of the Driver and its associated GSpace object
		entry void driveGSpace() {
			while(myGSpaceObj->cleanExitCalled!=1) {
				if ((cp_min_opt==1 && gen_wave==0) || isFirstStep==false) {
					serial {
						myGSpaceObj->thisProxy(thisIndex.x,thisIndex.y).startNewIter();
					}
					if (!_SDAG_DEBUG_PSI_OFF_) {

						// If called, releaseSFComputeZ() triggers an NL force computation.
						if (!_SDAG_DEBUG_SFNL_OFF_ && ees_nonlocal==0 && natm_nl!=0) serial {
							releaseSFComputeZ();
						}

						// Both branches of this if will trigger an NL force computation if
						// releaseSFComputeZ() was not called above.
						if (!_SDAG_DEBUG_VKS_OFF_) {
							serial { myGSpaceObj->doPsiFandVKS(); }
						} else if (!_SDAG_DEBUG_SFNL_OFF_ && ees_nonlocal==1 && natm_nl!=0) {
							serial { startNonLocalEes(myGSpaceObj->iteration); }
						}

						// Wait for both the VKS and the NL force computations to complete.
						overlap {
							if (!_SDAG_DEBUG_SFNL_OFF_) {
								when doneNLForces() {}
							}
							if (!_SDAG_DEBUG_VKS_OFF_) {
								when donePsiFandVKS() {}
							}
						}

						serial {
							myGSpaceObj->combineForcesGetEke();
						}
					} // !_SDAG_DEBUG_PSI_OFF_

					serial {
						myGSpaceObj->launchAtoms();
					}				

					if (!_SDAG_DEBUG_PSI_OFF_) {
						serial {
              // Check for output
							bool doOutput = config.stateOutput==1 &&
												CPcharmParaInfo::get()->cp_min_opt!=0 &&
												myGSpaceObj->iteration > 1 &&
												((myGSpaceObj->iteration-1)%CPcharmParaInfo::get()->ndump_frq==0 ||
													myGSpaceObj->iteration==config.maxIter ||
													myGSpaceObj->outputFlag==1);

              // Add constraint force, move the states, and correct for redundant entries in Psi.
							myGSpaceObj->doLambdaAndCgAndRedPsi(doOutput);
						}
            when doneLambdaAndCgAndRedPsi() {}
					}
				}
				if (!_SDAG_DEBUG_PSI_OFF_) {
					serial {
						bool doOutput = config.stateOutput==1 &&
											CPcharmParaInfo::get()->cp_min_opt==1 &&
											myGSpaceObj->iteration > 0 &&
											((myGSpaceObj->iteration)%CPcharmParaInfo::get()->ndump_frq==0 ||
												myGSpaceObj->iteration==config.maxIter ||
												myGSpaceObj->exitFlag==1);

						bool updateNeeded = CPcharmParaInfo::get()->cp_min_opt &&
												myGSpaceObj->iteration > 1 &&
												myGSpaceObj->iteration <= config.maxIter &&
												isPsiVupdateNeeded;

            // Orthonormalization
						myGSpaceObj->doNewPsiAndPsiV(doOutput, updateNeeded);
					}
          when doneNewPsiAndPsiV() serial { isPsiVupdateNeeded = false; }
				}
				overlap {
					if (!_SDAG_DEBUG_PSI_OFF_) {
						when doneComputingEnergy(const int AtomGrpIter) {}
					}
					when doneMovingAtoms(const int AtomsGrpIter) serial { myGSpaceObj->screenPrintWallTimes(); }
				}

				serial {
					isFirstStep = false;
				}
			} // end while simulation is running
			// Let the instance controller know we are finished
			serial {
				#ifdef _CP_SUBSTEP_TIMING_
					#if USE_HPM
						(TimeKeeperProxy.ckLocalBranch())->printHPM();
					#endif
				#endif
				int i=0;
				CkCallback cb(CkIndex_InstanceController::cleanExit(NULL),
								CkArrayIndex1D(thisInstance.proxyOffset),
								instControllerProxy);
				contribute(sizeof(int), &i, CkReduction::sum_int, cb);
			}
		};
	};
};



	
module gParticlePlane
{
	class UberCollection;
	class PPDummyMsg;
	
	message NLDummyMsg;
	message EnlCookieMsg;
	message GSPPIFFTMsg {complex data[];};
	
	array [2D] CP_State_ParticlePlane 
	{
		entry CP_State_ParticlePlane(int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int ,int, UberCollection);
		entry void launchComputeZs();
		entry void computeZ(PPDummyMsg *dmsg);
		entry void reduceZ(int size, int atmIndex, complex zmatrix[size],complex zmatrix_fx[size], complex zmatrix_fy[size],complex zmatrix_fz[size]);
		entry void getForces(int zsize, int atmIndex, complex zmat[zsize]);
		entry void lPrioStartNLEes(NLDummyMsg *m);
		entry [nokeep] void setEnlCookie(EnlCookieMsg *m);	
		entry void recvFromEesRPP(GSPPIFFTMsg  *m);
		entry void registrationDone(CkReductionMsg *msg);
		entry void printEnl(CkReductionMsg *msg);
	};
};




module gStatePlane
{
    extern module pcMessages;
    extern module instanceController;

	extern module RDMAMessages;
	class RDMApair_GSP_PC;
    class pcSetupMsg;
	message RDMASetupRequestMsg<RDMApair_GSP_PC>;
	message RDMASetupConfirmationMsg<RDMApair_GSP_PC>;
	message RSFFTMsg     { complex data[]; };
	message GSIFFTMsg    { complex data[]; };
	message GSRedPsiMsg  { complex data[]; };
	message GStateOutMsg 
	{
		complex data[];
		complex vdata[];
		int k_x[];
		int k_y[];
		int k_z[];
	};

	class UberCollection;
    include "paircalc/pcFwdDeclarations.h";
    include "load_balance/PeList.h";

	array [2D]  CP_State_GSpacePlane 
	{
		entry CP_State_GSpacePlane(int sizeX, int numG, int numR, int s_grain, int timekeepf, int timekeepb, UberCollection);
        entry void acceptPairCalcAIDs(pcSetupMsg *msg);
		entry void initGSpace(int m, complex pts[m], int mv, complex vpts[mv], int nx,int ny,int nz,int ngridaNL,int ngridbNL,int ngridcNL, int istart_cp);
		entry void acceptIFFT(GSIFFTMsg *msg);
		entry void completeRDMAhandshake(RDMASetupConfirmationMsg<RDMApair_GSP_PC> *msg);
		entry void collectFileOutput(GStateOutMsg *msg);

		entry void acceptLambda(CkReductionMsg *msg);
		entry void acceptLambda(partialResultMsg *msg);
		entry void acceptNewPsi(CkReductionMsg *msg);	
		entry void acceptNewPsi(partialResultMsg *msg);	
		entry void acceptRedPsi(GSRedPsiMsg *msg);	
		entry void acceptNewPsiV(CkReductionMsg *msg);
		entry void acceptNewPsiV(partialResultMsg *msg);
		entry void acceptRedPsiV(GSRedPsiMsg *msg);

		entry void makePCproxies();
		entry [local] void startNewIter();

		entry void computeEnergies(int p, double d);
		entry void acceptCgOverlap(CkReductionMsg *msg);
		entry void acceptNewTemperature(double temp);
		entry void readFile();
		entry [nokeep] void initBeadCookie(ICCookieMsg *msg);
		entry [nokeep] void minimizeSync(ICCookieMsg *msg);
		entry void setExitFlag();

		// Barriers
		entry [nokeep] void allDoneWritingPsi(CkReductionMsg *msg);
#ifdef BARRIER_CP_GSPACE_IFFT
		entry [nokeep] void allDoneIFFT(CkReductionMsg *msg);
#endif
#ifdef BARRIER_CP_GSPACE_PSI
		entry [nokeep] void allDonePsi(CkReductionMsg *msg);
#endif
#ifdef BARRIER_CP_GSPACE_PSIV
		entry [nokeep] void allDonePsiV(CkReductionMsg *msg);
#endif

// SDAG ////////
		entry void doPsiFandVKS() {
			serial {
        // Do the z-FFT
				doFFT();
        // Transpose by sending to RealSpaceStatePlane
				sendFFTData();	
			}
      // Wait for RealSpaceStatePlane to send back partially FFTd forces
			while (countIFFT != gs.planeSize[1]) {
				when acceptIFFT(GSIFFTMsg *msg) serial { unpackIFFT(msg); }
			}
			serial {
				countIFFT = 0;
        // Complete forces from VKS
				doIFFT();
			}
#ifdef BARRIER_CP_GSPACE_IFFT
      // For performance diagnostics enforce synchronization
			when allDoneIFFT(CkReductionMsg* msg) {}
#endif
			serial {
				UgSpaceDriverProxy[thisInstance.proxyOffset](thisIndex.x,thisIndex.y).donePsiFandVKS();
			}
		};

		entry void doLambdaAndCgAndRedPsi(bool doOutput) {
			// Lambda sending is needed for CgOverlap even if ortho is turned off
			serial {
        // We launch the computation of the constraint force
        sendLambda();
      }
			if (!_SDAG_DEBUG_ORTHO_OFF_) {
				while (countLambda != AllLambdaExpected) {
					case {
						when acceptLambda(CkReductionMsg *msg) serial { unpackLambda(msg); }
						when acceptLambda(partialResultMsg *msg) serial { unpackLambda(msg); }
					}
				}
				serial { doLambda(); }
			}
			serial { computeCgOverlap(); }
			when acceptCgOverlap(CkReductionMsg *msg) serial {
				psiCgOvlap(msg);
			}
			if (doOutput) {
				serial {
					writeStateDumpFile();
				} when allDoneWritingPsi(CkReductionMsg *msg) {}
			}
			serial {
        // Update the Psis using the forces modified by lambda
				integrateModForce();
        // At the gamma point synchronize redundant points on Gx = 0
				sendRedPsi();
			}
			while (iRecvRedPsi == 0) {
				when acceptRedPsi(GSRedPsiMsg *msg) serial { unpackRedPsi(msg); }
			}
			serial {
				doneRedPsiIntegrate();
				UgSpaceDriverProxy[thisInstance.proxyOffset](thisIndex.x,thisIndex.y).doneLambdaAndCgAndRedPsi();
			}
		};  // End routine

		entry void doNewPsiAndPsiV(bool doOutput, bool isPsiVupdateNeeded) {
			serial { sendPsi(); }
			if (!_SDAG_DEBUG_ORTHO_OFF_) {
				while (countPsi != AllPsiExpected) {
					case {
						when acceptNewPsi(CkReductionMsg *msg) serial { unpackNewPsi(msg); }
						when acceptNewPsi(partialResultMsg *msg) serial { unpackNewPsi(msg); }
					}
				}
				serial { doNewPsi(); }
#ifdef BARRIER_CP_GSPACE_PSI
				when allDonePsi(CkReductionMsg *msg) {}
#endif
			}
			if (doOutput) {
				serial {
					writeStateDumpFile();
				} when allDoneWritingPsi(CkReductionMsg *msg) {}
			}
			if (isPsiVupdateNeeded) {
				serial {
					acceptedVPsi = false;
					sendRedPsiV();
				}
				while (iRecvRedPsiV == 0) {
					when acceptRedPsiV(GSRedPsiMsg *msg) serial { unpackRedPsiV(msg); }
				}
				serial {
					doneRedPsiIntegrate();
					sendPsiV();
				}
				while (countVPsi != AllPsiExpected) {
					case {
						when acceptNewPsiV(CkReductionMsg *msg) serial { unpackNewPsiV(msg); }
						when acceptNewPsiV(partialResultMsg *msg) serial { unpackNewPsiV(msg); }
					}
				}
				serial { doNewPsiV(); }
#ifdef BARRIER_CP_GSPACE_PSIV
				when allDonePsiV(CkReductionMsg *msg) {}
#endif
			}
			serial {
				UgSpaceDriverProxy[thisInstance.proxyOffset](thisIndex.x,thisIndex.y).doneNewPsiAndPsiV();
			}
		};
	};
};
