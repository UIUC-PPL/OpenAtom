#include "fft_controller.h"
#include "fft_routines.h"
#include "controller.h"

static CmiNodeLock fft_plan_lock;
void init_plan_lock() {
  fft_plan_lock = CmiCreateLock();
}

FFTController::FFTController() {
  first_time = true;
  in_pointer = out_pointer = NULL;

  geps = new GSPACE();
  

  // TODO: A group dependency could probably solve this better
  contribute(CkCallback(CkReductionTarget(Controller, fftControllerReady), controller_proxy));
}

void FFTController::do_fftw() {
  fftw_execute(plan);
}

double calc_vol(double* a1, double* a2, double* a3){
  double a[3][3];
  double m[3][3];
  double vol;

  for (int i=0; i<3; i++){
      m[0][i] = a1[i];
      m[1][i] = a2[i];
      m[2][i] = a3[i];
  }

  /* compute matrix of cofactors */
  a[0][0] =  m[1][1]*m[2][2] - m[1][2]*m[2][1];
  a[1][0] = -m[1][0]*m[2][2] + m[1][2]*m[2][0];
  a[2][0] =  m[1][0]*m[2][1] - m[1][1]*m[2][0];
  a[0][1] = -m[0][1]*m[2][2] + m[0][2]*m[2][1];
  a[1][1] =  m[0][0]*m[2][2] - m[0][2]*m[2][0];
  a[2][1] = -m[0][0]*m[2][1] + m[0][1]*m[2][0];
  a[0][2] =  m[0][1]*m[1][2] - m[0][2]*m[1][1];
  a[1][2] = -m[0][0]*m[1][2] + m[0][2]*m[1][0];
  a[2][2] =  m[0][0]*m[1][1] - m[0][1]*m[1][0];

  vol = m[0][0]*a[0][0] + m[0][1]*a[1][0] + m[0][2]*a[2][0];
  return vol;
}

void FFTController:: calc_vcoulb(double* qvec, double* a1, double* a2, double* a3,
                                 double* b1, double* b2, double * b3, double shift[3],
                                 double alat, int nkpt, int iq){

  double* vcoulb;
  vcoulb = new double [geps->ng];
  double gx, gy, gz;
  double gq[3];
  double vol = calc_vol(a1, a2, a3);
  double fact = 4*PI/vol/nkpt;

  for (int i=0; i<geps->ng; i++) {
      if (iq==0){
          gx = geps->ig[i] + shift[0];
          gy = geps->jg[i] + shift[1];
          gz = geps->kg[i] + shift[2];
      }
      else{
          gx = geps->ig[i] + qvec[0];
          gy = geps->jg[i] + qvec[1];
          gz = geps->kg[i] + qvec[2];
      }

      vcoulb[i] = 0;
      for (int j=0; j<3; j++) {
          gq[j] =  gx*b1[j] + gy*b2[j] + gz*b3[j];
          gq[j] *= 2*PI/alat;

          vcoulb[i] += gq[j]*gq[j];
      }
      vcoulb[i] = 1/vcoulb[i];
      vcoulb[i] *= fact;
  }

  std::vector<double> vcoulb_v;
  vcoulb_v.resize(geps->ng);
  for(int i=0;i<geps->ng;i++)
    vcoulb_v[i] = vcoulb[i];
  controller_proxy.got_vcoulb(vcoulb_v);
}

void FFTController::get_geps(double epsCut, double* qvec, double* b1, double* b2, double * b3, 
                              double alat, int nfft[3]){

  int ndata = nfft[0]*nfft[1]*nfft[2];
  bool accept[ndata];
  int *gx, *gy, *gz;
    
  gx = new int [ndata];
  gy = new int [ndata];
  gz = new int [ndata];

  fftidx_to_gidx(gx, gy, gz, nfft);

//Values would need to be sent to Pmatrix geps

   double gxtmp, gytmp, gztmp;
    double vtmp[3];
    double Ekin;
    int eps_size = 0;
      
    for (int i=0; i<ndata; i++) { //can't be 0?
        gxtmp = gx[i] + qvec[0];
        gytmp = gy[i] + qvec[1];
        gztmp = gz[i] + qvec[2];//iq was removed assuming 0 index - might be wrong, since we have only one node
        /* transfer to cartesian unit to calculate energy */
        Ekin = 0;
        for (int j=0; j<3; j++) {
            vtmp[j] = gxtmp*b1[j] + gytmp*b2[j] + gztmp*b3[j];
            vtmp[j] *= 2*PI/alat;
            Ekin += 0.5 * vtmp[j] * vtmp[j];
        }
        
        if (Ekin <= epsCut) {
            accept[i] = true;
            eps_size += 1;
        }
        else{
            accept[i] = false;
        }

    }

    CkPrintf("[FFT CONTROLLER] Dimension of epsilon matrix = %d\n", eps_size);
    // set values
    geps->ng = eps_size;
    geps->ig = new int [eps_size];
    geps->jg = new int [eps_size];
    geps->kg = new int [eps_size];
   
    int j=0;

    for (int i=0; i<ndata; i++) {
        if (accept[i]) {
            geps->ig[j] = gx[i];
            geps->jg[j] = gy[i];
            geps->kg[j] = gz[i];
            j += 1;
        }
    }
   
    if ( j!= eps_size ) {
        CkPrintf(" Oops. Error when reducing gspace!!!");
    }

    geps->ig_diff = new int [eps_size*eps_size];
    geps->jg_diff = new int [eps_size*eps_size];
    geps->kg_diff = new int [eps_size*eps_size];

    int ngdata = eps_size;
    int k=0;

#ifdef DEBUG_2
    for (int i=0; i<ngdata; i++)
      CkPrintf("\ninit_geps->ig[%d] = %d\n", i+1, geps->ig[i]);
#endif
    for (int i=0; i<ngdata; i++) {
      for (int j=0; j<ngdata; j++) {
          geps->ig_diff[k] = geps->ig[j] - geps->ig[i];
          geps->jg_diff[k] = geps->jg[j] - geps->jg[i];
          geps->kg_diff[k] = geps->kg[j] - geps->kg[i];
//          CkPrintf("\ngeps->ig_diff[%d] = %d\n", k+1, geps->ig_diff[k]);
          k += 1;
      }
    }
   
    delete[] gx;
    delete[] gy;
    delete[] gz;

    std::vector<int> accept_v;
    std::vector<int> geps_x(eps_size);
    std::vector<int> geps_y(eps_size);
    std::vector<int> geps_z(eps_size);
    accept_v.resize(ndata);

    int counter = 0;
    for(int i=0;i<ndata;i++){
      if(accept[i]){
        accept_v[i] = 1;

        geps_x[counter] = geps->ig[counter];
        geps_y[counter] = geps->jg[counter];
        geps_z[counter] = geps->kg[counter];
        counter++;
      }
      else{
        accept_v[i] = 0;
      }
    }

    controller_proxy.receiveEpsDimensions(accept_v, geps_x, geps_y, geps_z, eps_size);
}

void FFTController::destroy_fftw_stuff() {
  fftw_destroy_plan(plan);
  fftw_free(in_pointer);
  fftw_free(out_pointer);
  in_pointer = out_pointer = NULL;
}

void FFTController::setup_fftw_3d(int nfft[3], int direction) {
  // check for some dumb input values
  if (nfft[0]<=0 || nfft[1] <=0 || nfft[2] <=0) {
    CkPrintf("setup_fftw_3d routine received illegal value for nfft. \
              nfft should be positive number.");
    CkExit();
  }
  if (!(direction==-1 || direction==1)) {
    CkPrintf("setup_fftw_3d routine received illegal value for direction. \
              FFTW direction must either 1 or -1");
    CkExit();
  }

  // if not the first time and any parameters (size, direction) mismatch
  // we need to destroy old plans to set up new ones
  if (!first_time && (direction != old_direction ||
      nfft[0] != old_nfft[0] ||
      nfft[1] != old_nfft[1] ||
      nfft[2] != old_nfft[2])) {
    destroy_fftw_stuff();
    first_time = true;
  }

  // if first time, we need to set up
  if(first_time) {
    const int ndata = nfft[0]*nfft[1]*nfft[2];
    in_pointer = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*ndata);
    out_pointer = (fftw_complex*) fftw_malloc(sizeof(fftw_complex)*ndata);

    CmiLock(fft_plan_lock);
    plan = fftw_plan_dft_3d(nfft[0], nfft[1], nfft[2],
        in_pointer, out_pointer, direction, FFTW_ESTIMATE);
    CmiUnlock(fft_plan_lock);

  }

  // now the old value changes to new value
  first_time = false;
  old_nfft[0] = nfft[0];
  old_nfft[1] = nfft[1];
  old_nfft[2] = nfft[2];
  old_direction = direction;
}
