// A module defining the various messages that are shared between modules
module messages {
  // A message used to package and send around psi arrays
  message PsiMessage {
    complex psi[];
  };

  // A message containing data being moved during a transpose
  message TransposeMessage {
    complex data[];
  };

  message Phase2Message {
    complex data[];
  };

  message Phase3Message {
    complex data[];
  };

  message Phase4Message {
    complex data[];
  };
};

module controller {
  extern module messages;
  readonly CProxy_Controller controller_proxy;
  readonly CProxy_FFTController fft_controller_proxy;
  readonly CProxy_PsiCache psi_cache_proxy;
  initnode void init_plan_lock();

  // Controls the coordination between the states, pmatrix, and cache based on
  // the configuration of pipeline depth, number of stages, etc.
  chare Controller {
    entry Controller();
    entry [reductiontarget] void fftControllerReady();
    entry [reductiontarget] void stateFFTComplete();
    entry [reductiontarget] void cachesFilled();
    entry [reductiontarget] void psiComplete();
    entry [reductiontarget] void fftComplete();
    entry [reductiontarget] void transposeComplete();
    //entry [reductiontarget] void printingComplete();
    entry [reductiontarget] void dataSendComplete();
    entry [reductiontarget] void phase2_complete();

    entry void run() {
      when fftControllerReady() serial {
        start = CmiWallTimer();
        CkPrintf("[CONTROLLER] Starting the controller @%f\n", start);
        states_proxy.fftGtoR();
      }

      when stateFFTComplete() serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] States FFTd @%f (elapsed %f)\n", end, end - start);
        start = CmiWallTimer();
      }

      // Tell the occupied psis to duplicate them in the cache, the wait for
      // the caches to report that they have been filled.
      for (next_K = 0; next_K < K; next_K++) {
        for (next_state = 0; next_state < L; next_state++) {
          serial { states_proxy(0, next_K, next_state).sendToCache(); }
        }
      }
      when cachesFilled() serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] Caches filled @%f (%f elapsed)\n", end, end - start);
        start = CmiWallTimer();
      }

      // Tell the unoccupised psis to send themselves to P, sending the first
      // chunk in the pipeline without waiting for any to complete.
      for (next_K = 0; next_K < K && total_sent < debug_stages; next_K++) {
        for (next_state = L; next_state < L + M && total_sent < debug_stages; next_state++) {
          serial {
            states_proxy(0, next_K, next_state).sendToComputeF();
            total_sent++;
          }
          if (total_sent >= pipeline_stages) {
            when psiComplete() serial { total_complete++; }
          }
        }
      }
      while (total_complete < K * M && total_complete < debug_stages) {
        when psiComplete() serial { total_complete++; }
      }

      serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] P Formed in real space @%f (%f elapsed).\n", end, end - start);
        start = CmiWallTimer();
        pmatrix2D_proxy.sendTo1D();
      }
      when dataSendComplete() serial{
        end = CmiWallTimer();
        CkPrintf("[PMATRIX] data is sent to 1d decomposition @%f (%f elapsed)\n", end, end - start);
        start = CmiWallTimer();
        pmatrix1D_proxy.fftRows(1);
      }
      when fftComplete() serial{
        CkPrintf("[PHASE2] fft #1 is done\n");
        pmatrix1D_proxy.doTranspose();

      }
      when transposeComplete() serial{
        CkPrintf("[PHASE2] transpose #1 is done\n");
        pmatrix1D_proxy.fftRows(-1);
      }
      when fftComplete() serial{
        CkPrintf("[PHASE2] fft #2 is done\n");
        pmatrix1D_proxy.doTranspose();
      }
      when transposeComplete() serial{
        CkPrintf("[PHASE2] transpose #2 is done\n");
        pmatrix1D_proxy.sendTo2D();
      }
      when phase2_complete() serial{
        CkPrintf("[PMATRIX] data back to original distirbution\n");
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] P formed in G space @%f (%f elapsed)\n", end, end - start);
      }
      serial{
        CkPrintf("[CONTROLLER] Exiting, waiting for phase3 to be implemented\n");
        CkExit();
      }
    }
  };

  group FFTController {
    entry FFTController();
  };

  // Caches psis locally on each node so they can be reused when forming P
  nodegroup PsiCache {
    entry PsiCache();
    entry [exclusive] void receivePsi(PsiMessage*);
    entry [exclusive] void computeFs(PsiMessage*);
    //entry void computeF(unsigned int, unsigned int, unsigned int);
  };
};

module states {
  readonly CProxy_States states_proxy;

  // An array containing all of the states in the system. After reading in the
  // states and performing an initial FFT it waits for the controller to tell it
  // where and when to send its data.
  array [3D] States {
    entry States();
    entry void fftGtoR();
    entry [reductiontarget] void sendToCache();
    entry [reductiontarget] void sendToComputeF();
  };  
};
